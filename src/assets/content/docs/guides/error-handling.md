# Error handling

Watson makes it increadibly easy to handle errors during command execution. You can throw an Exception that extends the abstract `EventExecutionException` class in all event related execution contexts like event handlers, command handlers and any kind of `configurable` like `pipes` or `guards`.

You will have access to two default exceptions for common use cases.

## Unauthorized Exception

Throw an `UnauthorizedException` when a user tries to use a command that he does not have permission for. A guard will for instance automatically throw a `UnauthorizedException` when its result is `false`.

```TS
import { UnauthorizedException } from '@watsonjs/common';

@Receiver()
export class UnauthorizedReceiver {

  @Command("unauthorized")
  throwUnauthorized() {
    if(!(/*Authorized*/)) {
      throw new UnauthorizedException();
    }

    return 'Authorized ;3';
  }
}
```

## Default handling

By default Watson will use the `CommonExceptionHandler` to catch this exception. In this case it will send back a message containing information about what went wrong during the command execution:

<div class="center-content">
<img src="http://localhost:4200/static/unauthorized.jpg">
</div>

## Bad Argument Exception

You can throw an `BadArgumentException` when a user tries to use a command with insufficient arguments. You will most likely use this command in pipes in which you validate the command message. If it were to not match your criteria you can throw this exception. In most cases though, Watson will throw this exception for you if you've specified the necessairy parameters in the command handler configuration.

```TS
@Receiver()
export class BadArgumentReceiver {
  @Command("badargument")
  throwBadArgument(@InjectParam("username") username: string) {
    if(username === undefined) {
      throw new BadArgumentException({
        name: "username",
        type: CommandArgumentType.STRING,
      } as ICommandParam);
    }
  }
}
```

## Default handling

By default Watson will use the `CommonExceptionHandler` to catch this exception. In this case it will send back a message containing specific information about what argument was missing and what the expected type would be. You also get an example command with all parameters:

<div class="center-content">
<img src="http://localhost:4200/static/bad-argument.jpg">
</div>

## Custom exceptions

If the default exceptions don't fit your needs you can easily create your own ones. To do so create a new exception class that extends the abstract `EventException` class. You'll then need to call the `super` constructor with the message that should be sent to the user. This can either be static or generated by your class using constructor params or whatever comes to mind.

```TS
import { EventException } from '@watsonjs/common';
import { MessageEmbed } from 'discord.js';

const CUSTOM_EMBED = new MessageEmbed();
CUSTOM_EMBED.title = "A custom exception was thrown! :0";

export class CustomException extends EventException {
  constructor() {
    super(CUSTOM_EMBED);
  }
}
```

As you can see in the example code you can also use `MessageEmbed` instances as they can be sent by the client. At this point Watson wont know how to handle the exception. Therefore it will just print the message to the console. To fix this we need to create our own exception handler.

## Exception handlers

Custom exception handlers can be implemented by extending the base `EventExceptionHandler` class. The abstract base will need you to implement a `catch` method which will handle the exception thrown. You can specify what exception the handler is responsible for when calling the `super` method in the constructor. In our case we want to handle all CustomExceptions that are thrown.

```TS
import { EventExceptionHandler, Injectable } from '@watsonjs/common';
import { Message } from 'discord.js';

import { CustomException } from './custom.exception';

@Injectable()
export class CustomExceptionHandler extends EventExceptionHandler {
  constructor() {
    super(CustomException);
  }

  async catch(err: CustomException) {
    const { data, context } = err;
    const { message } = context.getEventObj() as { message: Message };

    await message.channel.send(data);
  }
}
```

The `catch` method of the handler will be called with the exception thrown. Using the exception you then have access to the context which is of type `ExecutionContext` and the data (Which you have provided in the exception constructor) of the exception. For further information please head to the implementaion details for the <a href="https://github.com/M1CH3L1US/watson/blob/master/packages/common/src/exceptions/event.exception.ts">EventException</a>.

### Using the custom handler

You can apply custom handlers in a couple of ways. In the example below we specifically apply the exception handler to all exceptions thrown in this receiver. You can also use the `@UseExceptionHandler` decorator to decorate event methods or tell Watson to use them globally using the `addGlobalExceptionsHandler` method. You can use either specify type of the exception handler class if you want Watson to construct it and inject necessairy dependencies or use an instance of a handler class.

> You can only use class instances in the `addGlobalExceptionsHandler` method. Possibly add the handler as a provider and then get its instance using the `getProviderInstance` method.

Below you can see an example command used to create the screenshots for this article.

```TS
import {
  BadArgumentException,
  Command,
  CommandArgumentType,
  ICommandParam,
  InjectParam,
  Receiver,
  UnauthorizedException,
  UseExceptionHandler,
} from '@watsonjs/common';

import { CustomException } from './custom.exception';
import { CustomExceptionHandler } from './custom.handler';

@Receiver()
@UseExceptionHandler(CustomExceptionHandler)
export class ExceptionsReceiver {
  @Command({
    command: "throw",
    params: [{ name: "type", type: CommandArgumentType.STRING }],
  })
  handleThrow(@InjectParam("type") type: string) {
    if (type === "custom") {
      throw new CustomException();
    } else if (type === "unauthorized") {
      throw new UnauthorizedException();
    } else if (type === "argument") {
      throw new BadArgumentException({
        name: "param",
        type: CommandArgumentType.CHANNEL,
      } as ICommandParam);
    }
  }
}
```

<div class="center-content">
<img src="http://localhost:4200/static/custom-exception.jpg">
</div>
